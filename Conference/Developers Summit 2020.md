# Developers Summit 2020

## 最新のブラウザで変わるCookieの取扱いやプライバシーの考え方

- キーワード
  - Cookieについてのおさらい
  - 今3rd party cookieが非推奨になっている理由
  - ITP
  - Privacy Sandbox
- スライド
  - https://speakerdeck.com/yosuke_furukawa/zui-xin-falseburauzadebian-warucookiefalsequ-rixi-iyaprivacyfalsekao-efang
- セキュリティやプライバシー周りでブラウザの変更が多い
- safari
  - ITP
  - トラッキングを防止する仕組み
- firefox
  - ETP
  - ブラックリスト形式のリストがあり、マッチするとcookieが保存されない
- chrome
  - SameSiteCookie
  - UserAgent文字列を固定化
    - UAから個人を特定できるのでは? 解像度が高すぎて
  - 3rd party cookie
    - 廃止の方向
    - 異なるドメインのcookieは保存されなくなる
- cookieを用いたトラッキングの方法
  - ユーザに合った広告の出し方
- DNSのCNAMEレコードにドメインを追加してもらいドメインを1st party扱いにする方法がある
- トラッキングをしたい VS トラッキングを阻止したい
  - イタチごっこの状態
  - しかし、ただ単純に廃止したいわけではない
- UAが固定化されるとOSがWindowsになる(macでも)
  - Node.jsのインストールがWindowsになる
  - 1回のリクエストでは情報が取れなくなるのでサーバから情報を要求するような感じになる
    - 交渉しながらデータを取得するイメージ
- ブラウザ内で機械学習を行う
  - 個人情報のデータを送る必要がない(ブラウザ内で完結)

## CircleCIの3000 万件のワークフローから得られたDevOpsに関する知見

- 参考
  - https://services.google.com/fh/files/misc/state-of-devops-2019.pdf
- CircleCIがワークフローの分析結果を公開している
- CI/CDを使う動機
  - 自動化したい
  - コスト削減したい
  - 開発スピード
  - 品質……
- 優れたパフォーマンスを発揮しているチームはどのように使っているのか
- 対象データ
  - 月間3500万件以上のジョブ
  - 2019/6/1~8/30に確認された3000万強のワークフローデータ
  - 40000以上のorganization
  - 15万以上のプロジェクト
- ジョブ
  - DockerコンテナやVMなど実行環境が起動する単位
- ワークフロー
  - 複数のジョブを組み合わせて構築するCI/CDのパイプラインの全体
- メトリクス
  - スループット
    - デプロイ頻度(ワークフローが開始される頻度)
    - リードタイム(ワークフローの動作時間)
  - 安定性
    - 復旧時間(レッドビルドがグリーンビルドになるのに要する時間)
    - 失敗の頻度(ワークフローの失敗率)
- ワークフローの動作時間
  - 最遅
    - 3.3日
  - 中央値
    - 3分27秒
  - 最速
    - 2.1秒
  - プロジェクトに依存するため何分がベストか言い切れない
  - 最適なワークフローは数分から数十分程度
  - 開発者に適切なフィードバックを素早く行われること
    - 長さを短縮できるポイントを探すべき
- デプロイの頻度
  - 50%タイル
    - organizationレベル
      - 1日6回
    - プロジェクトレベル
      - 1日3回
    - デフォルトブランチレベル
      - 1日1回
  - 95%タイル
    - organizationレベル
      - 1日250回
    - プロジェクトレベル
      - 1日74回
    - デフォルトブランチレベル
      - 1日39回
  - 1日に10回以上のデプロイを行なっているプロジェクトは多くない
  - 非常に優れたチームは1日に数回のデプロイ
  - デプロイ回数が多い ≠ 優れたチーム
  - 組織がコードをテスト及び統合する頻度とエラーが発生した時の検知するスピードが重要
  - フィーチャーフラグでデプロイとリリースを切り離すことが可能
    - https://circleci.com/ja/resources/velocity-report/
- 復旧時間
  - 最遅
    - 30日
  - 中央値
    - 17.5時間
    - 一日の終わりにエラーを検知して次の日に修正することが多い
  - 最速
    - 1秒未満
  - デフォルトブランチ
    - 中央値
      - 1時間以内
  - 30%のプロジェクトでは90日間で一度も失敗していない
- 失敗の頻度
  - 27%はワークフローが失敗している
    - トピックブランチは31%
    - デフォルトブランチは18%
  - 50%はCI/CDパイプラインを変更しても一度も失敗していないプロジェクトの割合
    - 設定ファイルを使い回すか設定ファイルのパッケージング機能であるOrbsを使っているため
  - 多くはトピックブランチの失敗に起因している
    - GitFlowなどのプラクティスが有効に働いている
- エリート
  - 2019 State of DevOps report から
  - ワークフローの開始頻度
    - 1日に複数回デプロイ
  - ワークフローの期間
    - 1日未満
  - 復旧時間
    - 1時間未満
  - ワークフローの失敗率
    - 0~15%
- 言語特有の差異
  - PHPは失敗率が少ない

## noteの決して止まらないカイゼンを支える、エンジニアリングへの挑戦

- スライド
  - https://www.slideshare.net/KonYuichi/note-227802322/KonYuichi/note-227802322
- noteのグロースモデル
  - 単一のKPIを追わない
    - 売り上げの場合
      - クリエーター登録を過剰に促す
      - 有料記事が過剰にレコメンドされる など
- noteのチーム
  - グロースモデルを支えるチーム
  - 開発チームを分ける
    - 基盤
    - 機能開発
    - 改善
  - 基盤
    - グロースモデル全体を活性化して加速
    - push通知の基盤づくりなど
    - リリース頻度少ない
    - データ基盤
    - スパム対策
    - 課金基盤
  - 機能開発
    - 主要な機能を実装
    - リファクタリングなど
    - 各ラインを太くしていいく
    - リリース頻度は中くらい
    - エディタの開発
    - 漫画ビューアの開発
    - Nuxt.js移行
    - タイムライン改修
  - カイゼン
    - 線が途切れていないかチェックしたりする
    - アジリティが重視される
    - PDCAを回していく
    - リリース頻度は多い
    - 年間100以上の施策をリリース
  - バランス大事
    - チーム構成でバランスをとった
    - 後回しになりがちな施策も取りかかれるように
- noteのデータ
  - どこが穴抜けなのかチェックする必要が出てきた
    - データ活用して施策を設定
    - もう少し指標が細かくなったグロースモデルになった
  - データ収集のための分析基盤の構築
    - 読者から反応あるのが嬉しい
      - Likeボタンを設置
  - グロースモデルとデータで施策意思決定精度を上げる
- 何をやっていくのか
  - レコメンドの向上
  - パフォーマンス課題の向上

## 質とスピード

- スライド
  - https://speakerdeck.com/twada/quality-and-speed-2020-spring-edition
- 荒ぶる四天王
  - 時間
  - 予算品質
  - スコープ
- 品質は犠牲にされがち
  - 短期的なスピードは得られる
  - 長期的には致命傷
- 品質とは誰かにとっての価値
- ilities
- 狩野モデル
- 見える品質と見えない品質
  - 外部品質内部品質
  - 内部品質は結果ではなく原因
- 品質を犠牲=保守性
  - テスト容易性
  - 理解容易性
  - 変更容易性
- 果たして保守性を犠牲にしてスピードは上がるのか？
- 爆弾処理のようなリリース
- 保守性の低さがもたらすもの
  - 一つ一つの変更に余計な時間がかかる
  - 短期的には得られる
  - 中期的には逆効果
  - 長期的には致命傷
- スピードを落とせば保守性は上がる？
  - 時間をかけたとしてもその人の技術力以上のコードはかけない
  - 与えられた時間によって柔軟に汚さと速さを選択する器用なことはできない
- 保守性とスピードはトレードオフではない
  - コードの品質を高く保っていたからスピードが速い
- 4つのメトリクス
  - リードタイム
  - デプロイ頻度
  - 変更失敗率
  - MTTR
- 従来のメトリクス
  - 時間あたりのコード量
  - バグ数 とか
- 本当の関係
  - 内部品質がスピードをうみ
  - スピードが学びのループを生み
- どうやって個人の質を上げるのか
  - 自分で設計したシステムを長い間メンテすること
- テスト自動化の損益分岐点は4回
  - 手動テストと自動化されたテストのコストが逆転する
- 内部品質への投資の損益分岐点は一ヶ月以内に現れる
- 荒ぶる四天王はスコープを削る
  - リリースを取るかスコープを取るか

## Best Practices In Implementing Container Image Promotion Pipelines -知っておくべきコンテナイメージ・プロモーションの方法

- スライドのサイト
  - https://jfrog.com/shownotes/
  - https://noti.st/jbaruch/CNPyzR
- コンテナ = ほぼDocker
- Dockerは気に入っているがよく知っているわけではない
- docker build
  - Dockerfileに手順が記載されている
- 何もタグをつけないとlatestになる
  - 異なるイメージが作成される場合がある
  - バージョンをつければ少しはよくなる
    - イミュータブルの点ではよくない
    - パッチが当てられることがあるためバージョンが同じでも全く同じになるわけではない
    - チェックサムをつけるのはどうか?
      - でもそれって本当に求めているバージョンってわかる?
  - いつ振る舞いが変わるかわからない
  - promoteする
- 鉄板のpipelineを作ろう
  - LABELをつけておく
  - DockerRepositories
    - 環境毎にレジストリを分ける
- リポジトリ
  - トップレベルのディレクトリ
- レジストリ
  - それ以外のディレクトリ
- jfrogはイメージリポジトリを提供してくれる?
- Dockerで環境構築デプロイするとき
  - buildは一回だけ
  - 環境は分ける
  - ビルドしたものをプロモートする
  - 自分の依存関係は自分で管理する

## 礼節から育てるチームの健康と信頼性

- グループとチームの違い
  - 共通の目的がある
  - 協力して行動する
  - 相互に依存している
- なぜチームで働くのか
  - 一人でできることは限られているから
- プロセス知識スペクトル
  - ルーチンの作業
    - やり方はわかっている
    - 不確実性が少ない
      - 継続的なカイゼン
  - 複雑な業務
    - やり方がわかっていない
    - 不確実性が多い
      - 専門性を結集した問題解決
  - イノベーションの業務
    - どうやってゴールに到達するかわからない
    - 仮説検証による学習ループ
- 成果を出すチームの行動
  - 一人の学びをチームの学びに
  - 建設的な衝突が不可欠
- チームの健康と信頼性
  - 信頼性の高いチーム
    - 成果を出すための行動を自律的に継続できる
  - 健康なチーム
    - 建設的な衝突を人間関係のリスクなしに行える
- 建設的な衝突に必要なものは何か
  - 心理的安全性
    - カジュアルにやばいことを言える雰囲気
    - 対人関係にリスクがない状態
    - 不確実なこと不安なこと
    - あくまで建設的なこと(なんでも言って良いわけではない
- 心理的安全性についてよくある誤解
  - 仲良し = 心理的安全?
    - 飲みニケーション
    - 忖度
  - 正しければ何を言ってもいい
    - モヒカンの手斧
    - コードレビューは人格否定ではない
  - 目指すのはラーニングゾーン
- 礼節
  - HRTの原則
  - H
    - 謙虚
  - R
    - 尊敬
  - T
    - 信頼
  - 無礼とは
    - 攻撃的な言動
    - 自分が上であると誇示
    - チーム/仕事に無関心
  - なぜ有害なのか
    - 同僚の健康を害する
    - 会社に損害をもたらす
    - 周りの思考能力を下げる
    - 周りの認知能力を下げる
    - 周りを攻撃的にする
  - チームで働く上での礼節
    - 礼節はチームの一員としての責任
      - 周りのパフォーマンスを下げない
      - 自分の機嫌をメンテナンス
      - チームに関心を持つのも仕事
    - 礼節はプロトコル
      - コミュニケーションの約束
    - やばいことこそ礼儀正しく
      - 正しいことはそれだけで強い

## 少量データで軽量な機械学習の手法について

- キーワード
  - リザーバコンピューティング
- データの質と量
  - PoCを阻むデータと質と量の問題
  - 本当に必要なデータはあるのか
- ビックデータや既存のコンピューティングでは踏み込めない領域がある
- ユースケース(キャリブレーションに注目)
  - 個人に特化した目覚まし
    - 本人の体調
  - 個人に特化した歯磨きアドバイザ
    - 磨き位置
    - 磨いた回数
    - 歯の本数
    - 歯の形状
  - 状況にあわせてトンネル内で正確な位置特定(加速度センサで推論)
    - 走行距離
    - 左右のハンドリング
    - 運転の癖
    - タイヤの空気圧
    - 車体の状況
  - アポ先での受付コンシェルジュ(声から訪問客の情報を照合)
  - 自動議事録システム 会議支援システム
    - 音声から話者と内容を推論
    - 誰が何の話をしたのか議事録
    - 今の話題
    - 参加メンバーの事前データは取れない
  - 製造現場での異常検知
    - 製造ラインでの異常検知がしたい
    - データはまだとっていない
    - 異常データはそんなにない
    - 環境変化が激しすぎる
  - スマートウォッチによるパーソナルトレーナー
    - スマートウォッチの加速度センサで自動ロギング
    - 筋トレや泳法を判定したい
    - 回数も自動判定したい
    - トレーニングメニューをどんどん追加したい
  - キャリブレーションが必要な領域
    - 個人合わせる
      - ヘルスケア機器
      - 会議議事録


---


## レガシーコードからの脱却

- スライド
  - https://slide.meguro.ryuzee.com/slides/98
- レガシーコードとは
  - このセッションでは「理由は問わず修正、拡張、作業が難しいコード」
  - 保守に多額の費用がかかる
- 事前に変更を予知するのは不可能
  - 変更可能になるように書くべき
- 開発者の80%の時間は修正に使っている
- 品質は検査では上がらない
  - 品質の状況がわかるだけで、上がるわけではない
  - つまり最初からレガシーコードを書かない
- ソフトウェアが生み出す成果を決める要素
  - 問題設定力
    - そもそもユーザが問題と思っているのか
    - 問題を解決しないプロダクトは作らない
  - 開発力
    - プログラム言語
    - インフラ
    - 自動化
  - チーム力
    - 心理的安全性
    - 開発ルールが浸透している
- 最初からレガシーコードを作らないようにするにはどうすればいいのか
  - やり方より先に目的、理由、誰のためかを伝える
  - 小さなバッチで作る
  - 継続的に統合する
  - 協力し合う
  - CLEANコードを作る
  - テストを書く
  - テストで振る舞いを明示する
  - 設計は最後に行う
  - レガシーコードをリファクタリングする
- やり方より先に目的、理由、誰のためかを伝える
  - 役割の違い
    - PO
      - どういったものを作るか
      - 優先順位
      - ステークホルダーをマネージする
    - 開発チームの責任
      - リリース可能なプロダクトを作る
      - 設計、開発、テストをする
      - 決められた品質を満たす
  - 役割は分担する
    - Whatの人とHowの人
    - WhatはPOの役割
    - Howは開発者の役割
      - 物事のやり方は1つではなくやり方とトレードオフ
      - やり方を明示されると選択や交渉の余地が減る
      - 結果として手続き的なコードになりがち
  - ユーザストーリー
    - 機能について会話できるくらいの辛うじて十分なドキュメント
    - ストーリーが限定的であることでテスト可能になる
- 小さいバッチで作る
  - QCDSの何を調整するか
  - 品質を調整すると後から手直しに何倍もの時間を使うことになる
  - コストを調整=人を増やす
    - 人を増やしただけではオーバーヘッドによって成果は増えない
  - 一番調節すべきなのはスコープ
    - およそ半分の機能はほとんど使われない
  - タイムボックスによるアプローチ
    - 固定の期間内でタスクに取り組む
    - タスクの分割に慣れるまでには機能しやすい
    - ScrumやXP
    - も次回イテレーションで小さい嘘をつく
  - ソフトウェアの評価
    - 顧客にとって価値のあるものが評価となる
  - フィードバックサイクル
    - 小さいバッチの方がフィードナックの回数が増える
    - スプリントレビュー,CI/CDなど
    - 顧客とPOと同席
    - ビルドを高速化する
    - 価値やリスクに応じて取捨選択する
- CLEANコードを作る
  - 凝集性
    - それぞれの部品は1つのことだけ扱う
    - クラスが1つの責任に集中する
      - 名前が重要
  - 疎結合
  - カプセル化
    - 実装の詳細が外から見えなくなっている
  - 断定的
    - オブジェクトがフィールドなどを持つならそれらを管理する振る舞いを持つ
  - 非冗長
  - CLEANとテストでバグ発見の時期を早める
    - リリース直前だとバグ報告書などコストがかかる
- 素早く働く=綺麗に働く
  - これって5S


## 新しいHTML<portal>を利用した画面遷移設計 〜PayPayモールとYahoo!ニュースの事例を添えて〜

- 参考サイト
  - https://techblog.yahoo.co.jp/entry/20191118780830/
- キーワード
  - `<portal>`
- サービス紹介
  - Yahooニュース
    - 月間PV150億
    - 一日6000本の記事
  - PayPayモール
- Portalsの概要
  - 新しいHTML要素
  - ページの体感速度は速い方がいい
  - ネイティブアプリも速いけど体験できるまでが遠い
  - 指定のページにナビゲート
  - 指定のページの要素を取得
    - aタグやiframeタグでできていたことができる
- 導入事例
  - paypayモール
    - 検索ページから商品ページへの繊維にしよう
    - 商品がタップされたらportalで商品ページを取得
    - List to Detail
  - yahooニュース
    - Detail to Detail
    - 画面繊維がシームレス
- Portalsのデザイン
  - ページの繋がりをシームレスにできるという意識
  - 維持すらも可能になる
    - 音声を流しながら別の画面に遷移が可能
  - Webよりアプリの体験(表現)を参考にしやすい
  - 2つの考え方
    - プログレッシブエンハンスメント
      - https://developer.mozilla.org/ja/docs/Glossary/Progressive_enhancement
    - グレースフルデグラデーション
      - https://developer.mozilla.org/ja/docs/Glossary/Graceful_degradation
    - 非対応ブラウザ用にUIを検討する必要性
      - ちゃんとみんなが使えることが大事(リッチなUXに引きずられすぎない)
- Portalsの実装方法
  1. portalを埋め込む
  2. アニメーション
    - シームレスな遷移には必要
    - portal自体にはアニメーション機能が無いためCSSで設定する
  3.  画面全体に表示
  4.  `activate()`を実行
    - URLが変わる
  - メッセージを送ることも可能
    - `postMessage()`
  - WICGでしよう議論中
- Portals良い点・悪い点
  - 既存のMPAでもシームレスな画面繊維が実現できる
    - サービス規模によってはSPAは難しい
  - エンジニアだけではなくデザイナーも使える
    - デザイナーが理想とするユーザ体験とデザインを落とし込むことができた
  - 対応ブラウザ
    - 2020/2現在、Chromeでフラグを有効にした時のみ使える
  - インプレッションの計測が懸念
    - portalが取得された時に計測される
- 表現の幅が広がって楽しい(デザイナー目線)
- ユーザのストレスを軽減できるのが魅力(エンジニア目線)


## 全アプリ開発者に伝えたい、レガシーコードから脱却するための具体的な手法、“ルール駆動開発”

- 業務アプリケーションの設計・開発手法
  - クラウドネイティブアーキテクチャ
  - 初めから改修することを前提
  - レガシーアプリ移行時にも有効な手段
- ルール駆動開発
  - 業務ルール=ビジネスルール=ビジネスロジック
  - 3つの特徴
    - ルール（ロジック）とデータアクセスを完全分離
    - 業務目線でルールを整理
    - 小さく作ってはテストを行う
- 現行プラグラムコードの解析はNG
  - 秘伝のタレ状態
  - リファクタリングがされていない冗長なコード
  - 不要なゴミコードの山
    - コードから不要かどうか推測できない
    - 全て移行したら40%しか生きてるロジックがなかった場合もある
- 知りたいことは業務要件
  - 業務を知っている人に聞く
    - 1から10まで聞く必要はない
      - そもそも知っている人はいない
    - 誰でも知っている基本的なルール
    - 業務マニュアルなど
  - ヒアリング内容をDMNで整理
    - https://access.redhat.com/documentation/ja-jp/red_hat_decision_manager/7.3/html/designing_a_decision_service_using_dmn_models/dmn-con_dmn-models
  - システム用語ではなく業務用語で書く
- 一連の業務ルールをサービスとして切り出す
  - ルールとデータアクセスを分離
    - ルールのテストがしやすい
    - 改修時の影響範囲が狭まる
    - DB編成の変更影響を受けにくい
      - データ取得 ~ ルール実行 ~ データ登録　みたいな流れ
- 小さく作ってテストを繰り返しながらルールを育てていく
  - ルールのイテレーション開発
- 正しいルール駆動開発
  - システム担当と業務担当が協同で行う
  - 現行コードは見ない
  - 業務担当者が理解できる形式で実装
  - 幹となるルールから抽出
  - テスト及びユーザレビューを繰り返しながら品質向上
- NG
  - システム担当者のみで行う
  - 現行コード見る
- モノリスからマイクロサービスへ
  - 画面・ロジック・プロセス・データを分離することで
    - スパゲッティの解消
    - メンテナンス性の向上
    - 繰り返し開発方式へ
    - 開発生産性の向上
    - 分散環境に対応

## マルチクラウドに向けてNGINX活用促進する為に知っておいてほしいこと

- Nginx利用
  - Linux Server
  - Ansible
  - DockerHub
  - Official Dockerfile
  - CI/CD
- 同時接続の処理能力
  - Apacheと比べて多い
- Nginx Ingress Controller
  - gRPC
  - WebSocket
- Coustom Resources
  - ロードバランシングの重みつけ
- 監視運用
  - zabbixなど
- ドメインごとにルーティング
  - リバースプロキシ

## オープンソースのこれまでとこれから

- OSSは優れた開発手法
  - しかし、経済なき道徳は寝言になりつつある
  - エンジニア以外の人はあまりメリットを感じない?
- GNU Project
  - 最初は自由を求めていた
- 2000年くらい
  - MSと戦うために
    - Apache software foundation
    - Linux foundation
    - Eclipse foundation
  - XML parser
    - いくつかのプロジェクトがあった
    - 次第に競争が落ち着くと一本化して、今も細々とメンテナンスが続けられている
- オープンソーススタートアップ時代
  - 先に爆発的に普及させてからあとでお金を回収
- ユーザ企業の時代
  - 自社でサービスを提供している会社
    - AmazonとかGoogle
    - 日本で言えば楽天とかはてな
  - 技術的にも優れている
  - ベンダー < ユーザ企業
    - 面白い問題が存在しているのがユーザ企業
  - なぜユーザ企業がOSS?
    - 慈善事業ではない
    - コストの圧縮
      - 単に出すだけでは使ってくれないので同業他社を巻き込む
      - 自社でのメンテナンスコストを下げる
    - 開発者を雇うため
      - エンジニアの福利厚生
      - 求人活動の一環
  - 技術部門のリーダーにできること
    - 外部発信できる仕組み
  - NETFLIXがいい成功例
- オープンソースプログラム・オフィス
  - なぜ自社でOSSに貢献する必要があるのか明確にする
  - アウトバウンドが重要
  - 企業のためのオープンソースガイド
    - https://www.linuxfoundation.jp/resources/open-source-guides/
- Linux Foundation
  - 企業も主役
  - お金を人に変える仕組み
  - CNCFの成功
  - マーケッターとか企業からお金をもらいつつ、企業に還元させていくしくみがある
- コモディティの協同制作
  - 付加価値のない部分を自社で作ってもしょうがないのでみんなで作る流れ
  - 映画業界
    - https://www.aswf.io/
    - ACADEMY SOFTWARE FOUNDATION


## Hackが好きなエンジニアが組織をHackしてみる考えと実践を経てきたヒストリー

- 対象
  - マネジメント業務をやっているけどなんかモヤモヤしている
  - キャリア戦略としてマネジメントをしたい
- Hackに興味を持ったきっかけ
  - 2013年頃グロースハックという言葉が流行
- Hackの定義
  - Hackの意味に込めること
    - 構造におけるスキマを知ること
    - 構造のスキマを埋めること
  - ライフハックもグロースハックもそれぞれ何らかのスキマに入り込むこと
- マネジメントの苦悩
  - 仕事の対象
    - 人+プロジェクトという概念
  - 成果
    - 目の前の人が喜ぶこと?
  - 不確実性の高いものを相手にするので不安
  - エンジニアと比べ、成果がわかりにくい
  - マネジメント業務も開発業務をやっていた時と同じように考えてみる
- 苦悩を回避するために試みたこと
  - 見えないものを見えるようにする
    - 構造を理解する
  - 構造を理解した上でスキマに入り込む
- Hackを通した具体的な取り組み
  - 機能する組織を作っていく
  - エンジニア組織を会社の武器にしていく
- 機能する組織を作っていく
  - 背景
    - チームメンバーを大幅に増員する計画が発足
    - 何からやっていくべきか悩み始める
    - 相棒であるもう一人のマネージャーがどんどん色んなことを実施していく
      - 組織の成功循環モデル(ダニエル・キム)という構造から考えて裏付けがある行動だった
  - 構造を理解する
    - 機能する組織に必要なことを考え、組織の3要素（チェスターバーナード）に当てはめる
  - 見えてきたスキマ
    - プロジェクトが増えるがチームとしての協働が必要
    - 人数が増え、コミュニケーションが希薄化
    - チームとしての共通の目的は追い続けたい
  - スキマを埋める
    - 組織の方針を定める/見直す
      - 共通の目的
    - 自分たちの行動指針を自分たちで作る
      - 協働の意欲+コミュニケーション
- エンジニア組織を会社の武器にしていく
  - 背景
    - 経営レイヤーに技術畑出身者が少ない
    - 開発責任者になった
  - 色々考えてみた
    - 自社事業を持っている会社でのエンジニアの存在価値とは
    - 会社がエンジニアという役割に求めていることは何か
  - 構造を理解する
    - プロダクトマネジメントトライアングルに当てはめる
  - 見えてきたスキマ
    - 役割を全体的に整理できていない
  - スキマを埋める
    - プロダクトマネジメントトライアングルに対する不在役割の埋め方を埋め合わせる
    - その中で公人のキャリア戦略をプロットする
- クライテリア思考
  - 見えないものを見えるようにする考え方
  - 構造を理解することに繋がる考え方
  - https://qiita.com/hokutohagi/items/9482b0feb5513735c3d6

## 雲の中心で愛を叫ぶ！ クラウド横断パネルディスカッション

- どんな案件が増えている
  - AWS
    - 業種は問わず
      - EC
      - 医療
      - 金融
      - 最近は規模も大きくなっている(従業員数)
      - コンテナ需要も増えている
        - 昔はEC2でScaling
        - アジリティを考慮してコンテナ
  - Azure
    - エンタープライズ系
    - モダナイゼーション
  - GCP
    - DX案件
      - ユーザ企業は特に気にしている感じ
        - BigQueryの活用
          - Gsuiteと近づいている(スプレッドシート)
        - セキュリティ
- 推しているクラウドで便利
  - GCP
    - プロダクトが多くないところ
      - 洗練されている
    - アーキテクトで迷わない
      - 選択肢が少ないから
  - Azure
    - 開発に特化したサービス
      - AzureFunction
        - イベントがトリガーとなって動くというシンプルさ
        - 非同期さ
  - AWS
    - 何でもできる
      - サービス多い
      - 歴史がある
      - 選択肢が多く迷う
    - 進化の速さ(サービスの増加がすごい)
      - 飽きない
    - CDKによるIaC
      - https://dev.classmethod.jp/cloud/aws/cdk-workshop-typescript/
- 他のクラウドで羨ましいところ
  - Azure
    - AWSは開発者が活発
      - ユーザコミュニティ
      - JAWSとか
    - GCPはFirebase
      - 開発者が気軽に試せるサービスはいい
  - AWS
    - GCPは使おうとしているユーザがイケイケなイメージ
      - AppEngineから始まっているので目のつけている人は変わっている
    - Azure
      - MSライセンスを扱うのが楽
  - GCP
    - シェアがたくさんある
    - 公式ドキュメントが整ってる
    - サポートがいいらしい……
- クラウドによって自分のキャリアはどう変化した
  - AWS
    - エンジニアとしての市場価値について危機感
    - 今後も成長するし、食いっぱれることはない
  - Azure
    - 作るアプリケーションの種類が変わった
      - 言語は変わらなかった
  - GCP
    - 武器が変わった
      - オンプレ→クラウド
    - 最新の技術には最新の問題が転がっている
      - エンジニアにとっては良い
- クラウドは組み合わせるだけではなく、他にこだわりがないといけない
  - なぜこの組み合わせにするのかなど
- チームとして成果を出すには
  - AWS
    - 自分のスペシャリティを出す場合がある
    - 得意領域を別々に持っておく
  - Azure
    - サービスが多いので網羅するのは難しい
    - AWSと同じように細分化してメンバー同士で補っていく
    - 補うだけではなくアウトプットも行っていく
      - wikiとか
  - GCP
    - 自分の守備範囲を把握しておくこと
    - 他の人の守備範囲を把握しておくこと
- クラウドの学び方
  - GCP
    - 周りに広めるという気持ち
      - 自分に知識がないといけないので勉強する
    - 膨大なサービスについては覚えない
      - ざっくりでOK
  - Azure
    - 公式ドキュメントやGitHubのサンプルコード
    - microsoft run
  - AWS
    - 低レイヤーの知識は必要
    - 認定資格はよくできている(ベストプラクティス)