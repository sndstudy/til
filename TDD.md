# TDD

## 第1章 仮実装

- TODOリストを作成することでやるべきことを明確にする
    - どのような実装が必要か
    - どのようなテストを書くか
    - TODOリストに書き起こす
- テストを通すことを考える
    - 最初からすべてを綺麗に書こうとすると難しい
        - 仮実装を行う
    - テストを通す→その後コードを綺麗にする（リファクタリング）
- TDDのサイクル
    1. テストを1つ書く
    1. 全てのテストを実行し、追加したテストが失敗することを確認する
    1. テストが通るように実装を書きなおす
    1. 再びテストを実行し、全てが成功することを確認する
    1. リファクタリングを行って、重複を除去する
- TDDでは細かいステップを踏み続けられることが大切

### 所感

- TODOリストを用いて実装内容を明確にするのは簡単
    - 業務でも小さいタスクの管理はTODOで行っているのでとっつきやすかった
- 今までは一度で完璧なソースコード（例外処理も考慮しながら）を書こうとしていた
    - TDDでは仮実装など細かいステップで行っていくため、新鮮だった
        - しかし、あまりにもステップが細かいので続けれるのか不安
        - 経験を積み重ねていくことで慣れていくかも
- TDDのサイクルを知ることでJUnitなどのテストフレームワークが有用に感じた

## 第2章 明白な実装

- 頭の中でどういう実装をすればよいか既に浮かんでる場合はその実装をコードに写す
    - 仮実装と明白な実装を使い分ける
- 設計の問題点を発見してテストコードにした
    - 思っていることをテストコードに落としていって不安をなくしていく
- 空実装でコンパイルを通した
- 正しいと思う実装をすぐに行った
    - これが明白な実装

## 第3章 三角測量

- ValueObjectパターン
    - コンストラクタで設定したインスタンス変数の値が不変という制約がある
    - メリットは別名参照を気にする必要がない
        - 同じインスタンスを異なる変数に代入して片方の変数に格納されているインスタンスを変更するともう片方も変わってしまう事象が別名参照問題
    - ValueObjectにするにはインスタンスを操作した場合は新しいインスタンスを返すようにする
- 三角測量
    - 2つ以上の実例をテストコードに書き起こす
        - 2つ以上の実例がないと三角測量はできない
    - equalsメソッドを実装する時
        - 等しいときはtrueを返す
        - 等しくないときはfalseを返す
    - 2つ以上の実例が出たときにコードを一般化する必要がある
        - equalsの場合は値によってtrueかfalseを返す実装をする
        - trueやfalseをベタ書きにしたままでテストが通らない状態にしていくことをここでは一般化という
    - 三角測量をする時はテストコードとプロダクトコードの重複は一旦無視する

## 第4章 意図を語るテスト

- assertの比較を変数で行っていたがインライン化して変数に代入せずにメソッドの戻り値で比較している
    - インライン化前
        - `assertEquals(new Doller(10), product);`
        - 変数**product**が何を表しているかassertだけ見てもわかりにくい
            - 何のテストかわかりにくい
    - インライン化後
        - `assertEquals(new Doller(10), five.time(2));`
        - インライン化することで**five**に格納されている値が2倍した値が等しいかassertだけでわかる
            - テストの意図が分かりやすくなる
- インライン化
    - https://kotobank.jp/word/%E3%82%A4%E3%83%B3%E3%83%A9%E3%82%A4%E3%83%B3%E5%8C%96-977
    - https://ja.wikipedia.org/wiki/%E3%82%A4%E3%83%B3%E3%83%A9%E3%82%A4%E3%83%B3%E5%B1%95%E9%96%8B
    - メソッドの呼び出し箇所を呼び出しているメソッド内の処理に置き換えること
    - コンパイラの最適化手法の1つ
        - メソッドの呼び出しにかかるオーバーヘッドを削減する効果がある
- 等価性比較のテストで等価性比較の処理が正しく実装されていることを検証できていなければ今回のassertの変更も正しいかわからなかった
    - 片方が検証できていなければもう片方も検証できない事態になっていたかもしれないというリスクを受け入れた

## 第5章 原則をあえて破るとき

- 新しい機能を実装する際に既存のコードとテストコードをコピペする
    - これはTDDのサイクルの1つである「リファクタリングを行って、重複を除去する」をこの後必ず実施する前提でコピペしている
    - 重複を残したままにするのは絶対ダメ。あくまでも新しい機能を実装するきっかけ作りのために重複がある状態を一時的に許しているだけ

## 第6章 テスト不足に気づいたら

- 2つのクラスの共通の親クラスを作成する
    - 親クラスに実装を行ってから子クラスの実装を削除していく
    - 段階的に親クラスへ実装を写していく
        - メソッド内の処理に差異が無くなった場合は親クラスに実装していく
- 子クラスの実装（ここではequalsメソッド）を削除した時にテスト不足に気づく
    - もう片方の子クラスの等価比較のテストを書いていない
    - 書いていないのであれば追加する
- テストコードのないコードに対してリファクタリングをする場合
    - あればよかったというテストコードを書く
- テストコードにも重複が現れてしまった
    - 後でテストコードもリファクタリングしていく

## 第7章 懸念をテストに翻訳する

- 頭の中に「この場合のケースは想定の結果を返してくれるか？」と思ったらテストコードにする
    - 本の中ではFrancとDollarが比較されたとき、Falseを返すか懸念があったのでテストコードを書いていた
    - 結果、TrueになったのでFalseになるようにコードを修正した

## 第8章 実装を隠す

- テストコードにサブクラスを参照している箇所があった
    - サブクラスの構成が変わってしまうとテストコードに影響が出る可能性がある
- サブクラスを参照箇所を減らすためFactoryMethodを親クラスに定義する
    - 親クラスにサブクラスのインスタンス生成を任せる
- FactoryMethodを定義した結果、テストコードからサブクラスの存在を隠すことができた

p55から