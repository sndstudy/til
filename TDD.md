# TDD

## 第1章 仮実装

- TODOリストを作成することでやるべきことを明確にする
    - どのような実装が必要か
    - どのようなテストを書くか
    - TODOリストに書き起こす
- テストを通すことを考える
    - 最初からすべてを綺麗に書こうとすると難しい
        - 仮実装を行う
    - テストを通す→その後コードを綺麗にする（リファクタリング）
- TDDのサイクル
    1. テストを1つ書く
    1. 全てのテストを実行し、追加したテストが失敗することを確認する
    1. テストが通るように実装を書きなおす
    1. 再びテストを実行し、全てが成功することを確認する
    1. リファクタリングを行って、重複を除去する
- TDDでは細かいステップを踏み続けられることが大切

### 所感

- TODOリストを用いて実装内容を明確にするのは簡単
    - 業務でも小さいタスクの管理はTODOで行っているのでとっつきやすかった
- 今までは一度で完璧なソースコード（例外処理も考慮しながら）を書こうとしていた
    - TDDでは仮実装など細かいステップで行っていくため、新鮮だった
        - しかし、あまりにもステップが細かいので続けれるのか不安
        - 経験を積み重ねていくことで慣れていくかも
- TDDのサイクルを知ることでJUnitなどのテストフレームワークが有用に感じた

## 第2章 明白な実装

- 頭の中でどういう実装をすればよいか既に浮かんでる場合はその実装をコードに写す
    - 仮実装と明白な実装を使い分ける
- 設計の問題点を発見してテストコードにした
    - 思っていることをテストコードに落としていって不安をなくしていく
- 空実装でコンパイルを通した
- 正しいと思う実装をすぐに行った
    - これが明白な実装

## 第3章 三角測量

- ValueObjectパターン
    - コンストラクタで設定したインスタンス変数の値が不変という制約がある
    - メリットは別名参照を気にする必要がない
        - 同じインスタンスを異なる変数に代入して片方の変数に格納されているインスタンスを変更するともう片方も変わってしまう事象が別名参照問題
    - ValueObjectにするにはインスタンスを操作した場合は新しいインスタンスを返すようにする
- 三角測量
    - 2つ以上の実例をテストコードに書き起こす
        - 2つ以上の実例がないと三角測量はできない
    - equalsメソッドを実装する時
        - 等しいときはtrueを返す
        - 等しくないときはfalseを返す
    - 2つ以上の実例が出たときにコードを一般化する必要がある
        - equalsの場合は値によってtrueかfalseを返す実装をする
        - trueやfalseをベタ書きにしたままでテストが通らない状態にしていくことをここでは一般化という
    - 三角測量をする時はテストコードとプロダクトコードの重複は一旦無視する

## 第4章 意図を語るテスト

- assertの比較を変数で行っていたがインライン化して変数に代入せずにメソッドの戻り値で比較している
    - インライン化前
        - `assertEquals(new Doller(10), product);`
        - 変数**product**が何を表しているかassertだけ見てもわかりにくい
            - 何のテストかわかりにくい
    - インライン化後
        - `assertEquals(new Doller(10), five.time(2));`
        - インライン化することで**five**に格納されている値が2倍した値が等しいかassertだけでわかる
            - テストの意図が分かりやすくなる
- インライン化
    - https://kotobank.jp/word/%E3%82%A4%E3%83%B3%E3%83%A9%E3%82%A4%E3%83%B3%E5%8C%96-977
    - https://ja.wikipedia.org/wiki/%E3%82%A4%E3%83%B3%E3%83%A9%E3%82%A4%E3%83%B3%E5%B1%95%E9%96%8B
    - メソッドの呼び出し箇所を呼び出しているメソッド内の処理に置き換えること
    - コンパイラの最適化手法の1つ
        - メソッドの呼び出しにかかるオーバーヘッドを削減する効果がある
- 等価性比較のテストで等価性比較の処理が正しく実装されていることを検証できていなければ今回のassertの変更も正しいかわからなかった
    - 片方が検証できていなければもう片方も検証できない事態になっていたかもしれないというリスクを受け入れた

## 第5章 原則をあえて破るとき

- 新しい機能を実装する際に既存のコードとテストコードをコピペする
    - これはTDDのサイクルの1つである「リファクタリングを行って、重複を除去する」をこの後必ず実施する前提でコピペしている
    - 重複を残したままにするのは絶対ダメ。あくまでも新しい機能を実装するきっかけ作りのために重複がある状態を一時的に許しているだけ

## 第6章 テスト不足に気づいたら

- 2つのクラスの共通の親クラスを作成する
    - 親クラスに実装を行ってから子クラスの実装を削除していく
    - 段階的に親クラスへ実装を写していく
        - メソッド内の処理に差異が無くなった場合は親クラスに実装していく
- 子クラスの実装（ここではequalsメソッド）を削除した時にテスト不足に気づく
    - もう片方の子クラスの等価比較のテストを書いていない
    - 書いていないのであれば追加する
- テストコードのないコードに対してリファクタリングをする場合
    - あればよかったというテストコードを書く
- テストコードにも重複が現れてしまった
    - 後でテストコードもリファクタリングしていく

## 第7章 懸念をテストに翻訳する

- 頭の中に「この場合のケースは想定の結果を返してくれるか？」と思ったらテストコードにする
    - 本の中ではFrancとDollarが比較されたとき、Falseを返すか懸念があったのでテストコードを書いていた
    - 結果、TrueになったのでFalseになるようにコードを修正した

## 第8章 実装を隠す

- テストコードにサブクラスを参照している箇所があった
    - サブクラスの構成が変わってしまうとテストコードに影響が出る可能性がある
- サブクラスを参照箇所を減らすためFactoryMethodを親クラスに定義する
    - 親クラスにサブクラスのインスタンス生成を任せる
- FactoryMethodを定義した結果、テストコードからサブクラスの存在を隠すことができた

## 第9章 歩幅の調整

- ちょっとした割込み（リファクタリングの際に別の個所で不具合を発見して修正している時など）をしている時にそこからさらに割込みをしない
- 1つのサブクラスをリファクタリング(小さい歩幅)でした後に別のサブクラスを大きな歩幅で修正する
    - 修正箇所やタイミングによって修正の歩幅を変える

## 第10章 テストに聞いてみる

- 2つのサブクラスの処理を共通化して親クラスに実装するために試しにメソッド内の処理をインライン化してみた
- プロダクトコードを変更した後にテストを実行した（処理の変更を試みた）
    - 変更しても実装が壊れていないかテストに聞いてみた
- 実装が壊れたのでグリーンバーが表示されるところまでプロダクトコードを戻した
    - 戻した後、変更したい処理に関するテストコードを追加した

## 第11章 不要になったら消す

- サブクラスの処理を親クラスに実装しなおしていった
    - 不要なテストコードが出てきたので削除していった
    - ここではサブクラスの参照に関係するテストやサブクラス削除前の構造で意味があったものなど

## 第12章 設計とメタファー

- Money自身が計算をするのはおかしいと考えたのでExpression(式)というメタファーを考えた
    - Money自体に処理を追加すると役割が大きくなってしまうので別のオブジェクトに役割を与えた
- メタファーはプログラマの数だけ存在する(Bankもメタファーになりえるため)

## 第13章 実装を導くテスト

- テストコードに実装予定のテストを書く
    - 実装のゴールを決めるためのテスト
    - テストが通ったときは予定していた実装ができたということ
        - しかし、綺麗なコードではないのでリファクタリングすること
- 実装に導くためのテストコードは内部の実装に関係するため長く生きしないテストコードになる

## 第14章 学習用テストと回帰テスト

- 学習用テスト
    - 言語仕様やライブラリの挙動について調べるときに書くテスト
    - 今回はJavaの配列のequalsメソッドは配列の中の要素まで等価比較を行うのか検証した
- 回帰テスト
    - 例外やバグが発生した時の状況を再現するためのテスト
    - 今回は同じ通貨の為替レートを1で返さなければならないのに例外が発生していた

## 第15章 テスト任せとコンパイラ任せ

- ゴールのテスト（こうなったらいいなと思うテスト）を書く
    - コンパイルエラーになったらテストコードを後退（ゴールの一歩手前）させてコンパイルを通るようにする
- 一般化（抽象度を高くする）の作業を末端から行って、テストケースまで到達させる
- 変更した際にコンパイラのエラーに従って1つずつ対処した

## 第16章 将来の読み手を考えたテスト

- 読み手のことを考えてあえて冗長的なテストコードを書く
- TDDを行うとプロダクトコードとテストコードの量が同じくらいになる
    - 2倍のコード量を書けるようになるか、半分のコード量で同じ機能を実装できるようにならないとメリットが感じられない
        - デバッグや人に説明する時間も考慮すること

## 第17章 多国通貨の全体ふりかえり

- 同じ機能を何回も書いていくうちにメタファーが考えつく
    - 著者は本書を書いているうちに式のメタファーを思いついた
- TDDで作成されるテストはシステムを開発し続けるのに有用
    - パフォーマンステスト、負荷テスト、ユーザビリティテストの代替にはならない
- テスト評価手法
    - ステートメントカバレッジ
    - 欠陥挿入
        - プロダクトコードの任意の行の意味合いを変えたらテストは失敗しなければならない
        - 機能によっては意味合いを変えてもテストが成功する場合がある（hashCodeメソッドなど）

## 第25章 テスト駆動開発のパターン

- 独立したテスト
    - テストの実行は他のテストに影響を及ぼすべきではない(実行の順番に依存されないようにする)
        - 1つ目のテストでDBにデータを登録し、2つ目のテストでそのデータを使うというのはNG
    - テストの実行速度を速くしたいという理由でデータを共有させたい場合はテストの粒度をもっと細かくしてみる
        - テストを独立させたのにテストのパフォーマンスが劣化するのは1ケースの粒度が大きすぎる場合がある
    - 独立させることでピンポイントでエラーが出たテストのみを再実施することができるため
- TODOリスト
    - 何か考え付いたときは「すぐやる」「あとで」のリストにすぐ加える
        - TDDの場合は実装したいものに対するテストを加えるイメージ
    - 目の前のスコープに収まらない大きなリファクタリングは「あとで」に加える
    - テストケースは「すぐやる」に加える
        - まだ動作しないテストを思いついたのなら、それを動作させるほうが大事
- テストファースト
    - いつテストを書くべきか
        - テスト対象のプロダクトコードを書く前
- アサートファースト
    - いつアサーションを書くべきか
        - 最初に書く
    - どこからテストを書き始めるべきか
        - テストの終わりにパスすべきアサーションを書くところから
    - テストを書くときは複数の問題を一度に解こうとしている場合がある
        - 機能はどこに属すべきか
        - 名前付け
        - 結果の正しさをどう検証しようか
        - このテストから想起される新たなテストはないだろうか
    - アサーションを先に書くことでテストをシンプルにすることができる
        - このアサーションをパスするには……という具合に実装内容を想像する
- テストデータ
    - テストファーストで扱うテストデータはどういったものが良いか
        - テストを読みやすく、理解しやすくするデータ
    - データに違いがあるのなら意味のあるデータを扱う
        - 1と2に意味の違いが無ければ1を使おう
    - データのテクニックとして同じ値は1つのものを表すためだけに使う
        - 足し算では影響ないが引き算の場合は影響が出る可能性がある
    - 本物に近いデータ
        - 外部機器からイベントを収集して解析するリアルタイムシステム
        - 新システムと旧システムの出力内容が一致するテスト
- 明示的なデータ
    - データの意図をどのように示すか
        - 期待値と結果をテスト自身に含め、それらの関係が明快にわかるようにする
        - テストコードにあえてマジックナンバーを書く方法がある
            - 数値がそのまま書かれているので分かりやすい

## 第26章 レッドバーのパターン

- 一歩を示すテスト
    - TODOリストから次に書くテストを選ぶ場合
        - 何かを学ぶことができ、かつ実装に自信が持てるようなテストを選択する
        - 仮実装まで想像が出来ているもの?
- はじめのテスト
    - 出力と入力が完全に一致するケース
    - 入力が限りなく小さいケース
        - 入力データがシンプルなもの
- 説明的なテスト
    - テストコードの中で他人と知識を共有する
    - シーケンス図で説明された内容をテストコードに書き直していく
- 学習用テスト
    - チーム外の人が書いたソフトウェアやライブラリを使う場合
        - ソフトウェアの機能を初めて使う場合にテストを書いてみる
        - 自分が期待している動作をするのかテストで確かめる
    - 依存しているパッケージが新しいバージョンをリリースした場合は学習用テストを書く
        - もし学習用テストが失敗したらプロダクトコードも動かないことがわかる
- 脱線はTODOリストへ
    - リファクタリングや実装中に別のアイディアが浮かんだらTODOリストに追加する
- 回帰テスト
    - 不具合が報告された場合
        - 不具合を再現するテストケースを書いて失敗することを確認する
        - そのテストが通るようになれば不具合が修正されたことになる
- やり直す
    - 手詰まりになったときはコードを捨ててやり直すことも必要

## 第27章 テスティングのパターン

- 小さいテスト
    - 大きいテストが失敗した場合
        - 大きいテストから問題箇所を絞り込んだテストを書く
- Mock Object （擬装オブジェクト）パターン
    - 準備がかかるリソースに依存したオブジェクトをテストする場合
        - 決められた結果を返す、偽のオブジェクトを代わりに作成する
    - 擬装オブジェクトは可読性を上げる
        - テストコードが理解しやすくなる
        - 本物のリソースでテストする場合なぜその値が返ってくるのか判断するのが難しい
    - 擬装オブジェクトを使用するとオブジェクトの可視性を考慮するようになる
        - コードの結合度を低くすることができる
    - 擬装から本物に切り替える場合
        - 本物のリソースに対しても擬装と同じテストを走らせればよい
        - 擬装と本物が異なる動きをする場合のリスクを軽減できる
- Self Shunt（自己接続）パターン
    - オブジェクトが他のオブジェクトとやり取りをしていることをテストしたい場合
        - テスト対象オブジェクトが本物だと思っている相手が実はテストケース自身となるようなテストを書く
        - 別のオブジェクトを用意するのではなく、テストコード上に実装する
    - Self Shuntパターンで実装するべき処理を「インタフェースの抽出」を行う場合がある
        - インタフェースに抽出するのが簡単か既存クラスをブラックボックスとしてテストするほうが簡単か判断する必要がある
- Log String（記録用文字列）パターン
    - 正しい順番でメソッドが呼ばれているかテストしたい場合
        - 記録用の文字列を作成し、メソッド呼び出しの度に文字列を追記する
        - 文字列を追記するだけなのでテストが読みやすい
    - メソッドが呼ばれているかを確認する必要はあるが順序を気にしない場合はSetに格納して比較すればよい
    - Observerパターンで実装をしていて、特定の順番で実行されていることを検証したいときに役に立つ
    - Self Shuntパターンと相性がよい
        - インタフェースの実装でもあるテストケース自身が記録用文字列を追記しつつ、値を返せばいいため
- Crash Test Dummy（衝突実験ダミー人形）パターン
    - 普通のやり方では到達させるのが難しい、エラー処理部分のコードをテストする場合
        - 例外を発生させる特別なオブジェクトを使用してテストをする
    - 仮実装をで実現することができる
        - Mock Objectパターンに似ているがオブジェクト全体を擬装する必要は無い
        - Javaであれば匿名クラスを使用して対象メソッドだけを上書きして例外状況を再現させるメソッド実装に置き換えればよい
- 失敗させたままのテスト
    - コーディング時間のうまい終わらせ方
        - 最後に書いたテストを失敗したままにする
            - その時何を考えていたか思い出しやすくなる
            - どこからコーディングを再開すればよいか明確になる
- きれいなチェックイン
    - チーム内でのコーディング時間の終わらせ方
        - テストを全て通る状態にする
    - チェックイン前に走らせるテストは手元で走らせているテストよりも広範囲をカバーしている
        - 結合テストで失敗する場面が出てきた場合は「手元の作業を捨てて初めからやりなおし」がシンプルなルール
        - このルールを採用したチームは早くチェックインしようと考える
            - 最初にチェックインした人は何も失わないから
        - 頻繁なチェックインは好ましい文化
            - バグの検知が早まるため
    - テストを通すためにテストをコメントアウトするのは絶対に禁止

## 第28章 グリーンバーのパターン

- 仮実装
    - 失敗するテストを書いてから最初にどのような実装を行うべきか
        - べた書きの値を返す実装をする
        - べた書きの値を徐々に本物の処理や変数に置き換えていく
    - 仮実装の有効性
        - 心理的効果
            - グリーンとレッドでは精神状態が異なる。グリーンであれば自信をもってリファクタリングができる。
        - スコープ制御
            - 仮の値から本物の実装に置き換えるときにスコープを気にすることができる
- 三角測量
    - テストから一般化を引き出すやり方
        - 2つ以上の例があるときだけ一般化を行う
    - テストコードを書いてアサーション2つ以上の例を書くことができればプロダクトコードを一般化する
        - 足し算のメソッドを実装し、テストを行う場合など
            - `assertEquals(4,plus(3,1));`
            - `assertEquals(7,plus(3,4));` など
- 明白な実装
    - シンプルな処理を実装する場合
        - そのまま実装する
    - 仮実装や三角測量は細かいステップ
        - 既に実装内容が見えている場合はそのまま実装を進める
    - 明白な実装を行っているときにレッドバーが予想より多く出た場合は注意する
        - この場合は実装のステップを小さくする
- 一から多へ
    - オブジェクトのコレクションを扱う操作を実装する場合
        - まずは単数の場合を実装し、それからコレクションでも動くようにする

## 第29章 xUnitのパターン

- アサーション
    - テストの成否を真偽値で行う
    - 変数を使ってテストの成否を確認している場合は要注意
        - 変数を直接見るのは設計が良くない場合があるので改善のチャンス
    - テスト失敗時のアサーションメッセージを詳しく書くことでエラー原因がわかりやすくなる
- フィクスチャー
    - 複数のテストから使われる共通のオブジェクトが必要な場合
        - テストメソッド内のローカル変数をインスタンス変数に引きあげてsetUpメソッドなどテスト実施前に実行されるメソッドで初期化する
    - テスト事前準備のコードが長くなる場合がある
        - setUpメソッドにまとめる
            - 基本はこっち
        - テスト毎に事前準備のコードを書く
            - テストが読みやすくなるが冗長的
- 外部フィクスチャー
    - フィクスチャーとして作成した外部リソースを解放したい場合
        - tearDownメソッドなどテスト実施後に実行されるメソッドで開放する
- 例外のテスト
    - 例外発生を期待するテストを作成する場合
        - 期待される例外をキャッチして握りつぶすように書く
        - 期待した例外が発生しないときだけテストを失敗させるようにする
            - failメソッドを呼び出す
            